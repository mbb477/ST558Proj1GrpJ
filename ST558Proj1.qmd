---
title: "ST558 Project 1"
author: "M. Sweitzer, M. Beebe"
format: html
editor: visual
---

# Data processing first steps

One of the goals of this project is to create a function that can take in a URL and process and parse similar types of data sets in a specific way. The data sets we are working with are files that contain Census Bureau information.

### Import the Data

We will start with the EDU01a data set and use it to outline the steps that will be necessary to create our wrapper function. To begin, the appropriate packages are loaded and the data imported using read_csv. This function is appropriate for csv files. The data already contains column names, which is the default for this function, so it is not necessary to specify an argument regarding column names.

```{r, echo=FALSE}
suppressPackageStartupMessages(library(tidyverse))
```

```{r}
library(tidyverse)
library(readr)
census_1a_original <- read_csv("https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv")
head(census_1a_original)
```

### Steps 1 and 2: Select Columns and Pivot to Long Form

The next step is to select the columns we are interested in, followed by pivoting the data into a long format, which is more appropriate for data analysis. In this case, we are selecting Area_name, which is also being renamed to area_name, STCOU, which is a state (first 2 digits) and county (last 3 digits) code and all columns that end with a "D". These columns ending in "D" correspond to an id that identifies the type of survey and value associated with it and the 2 digit year.

```{r}
census_1a_condensed <- census_1a_original |>
  select(Area_name, STCOU, ends_with("D")) |>
  rename(area_name = Area_name) |>
  pivot_longer(cols = 3:12, 
               names_to = "item_id", 
               values_to = "enrollment")
head(census_1a_condensed) 
```

### Step 3: Add Year and Survey Code Columns

Next, we want to pull out the year from the item_id and convert it to an appropriate, 4-digit form placed in it's own column. We also want to isolate and put in it's own column the portion of the item_id that corresponds to the survey code and value associated with it. We can use the mutate function to add these columns. The substr() function allows you to extract a string based on position. For the year, for example, the numbers corresponding to the year are in the 8th and 9th position of the 10 character string. Then we add 1900 to the extracted 2 digit number to obtain the 4 digit year. The survey code is extracted in a similar manner.

```{r}
census_1a_add <- census_1a_condensed |>
  mutate(year = (as.numeric(substr(item_id, 8, 9)) + 1900),
         survey_code = substr(item_id, 1, 7))
census_1a_add
```

### Step 4: Create Two Data Sets

In this step, we separate the observations into two data sets based on the presence or absence of a character string pattern in the area_name variable, which is indicative of county level or non-county level data, respectively. From here, we also assign a "county" or "non-county" class to each new data set.

```{r}
county_data <- census_1a_add |>
  filter(grepl(pattern = ", \\w\\w", area_name))

noncounty_data <- census_1a_add |>
  filter(!grepl(pattern = ", \\w\\w", area_name))

class(county_data) <- c("county", class(county_data))
class(noncounty_data) <- c("state", class(noncounty_data))

head(county_data)
head(noncounty_data)
```

### Step 5: Add New Variable for County Data

Within the county data set, we now extract the last two characters of the area_name variable, indicating which state the county is located in, and we store this in a new "state" variable.

```{r}
county_data <- county_data |>
  mutate(state = substr(area_name, nchar(area_name)-1,
                        nchar(area_name)))
county_data
```

### Step 6: Add New Variable for Non-County Data

For the non-county data set, we use a series of "ifelse" statements to indicate the set of states belonging to each U.S. division, creating a new "division" variable to store this information. When the area in question is not a state (e.g., UNITED STATES), this will return "ERROR".

```{r}
noncounty_data <- noncounty_data |>
  mutate(division = ifelse(area_name %in% c(
    "CONNECTICUT", "MAINE", "MASSACHUSETTS", "NEW HAMPSHIRE", 
    "RHODE ISLAND", "VERMONT"), "New England",
    ifelse(area_name %in% c(
      "NEW JERSEY", "NEW YORK", "PENNSYLVANIA"), 
      "Middle Atlantic", 
      ifelse(area_name %in% c(
        "ILLINOIS", "INDIANA", "MICHIGAN", "OHIO", "WISCONSIN"),
        "East North Central", 
        ifelse(area_name %in% c(
          "IOWA", "KANSAS", "MINNESOTA", "MISSOURI", "NEBRASKA",
          "NORTH DAKOTA", "SOUTH DAKOTA"), "West North Central",
          ifelse(area_name %in% c(
            "DELAWARE", "FLORIDA", "GEORGIA", "MARYLAND", 
            "NORTH CAROLINA", "SOUTH CAROLINA", "VIRGINIA",
            "DISTRICT OF COLUMBIA", "District of Columbia", 
            "WEST VIRGINIA"), "South Atlantic",
            ifelse(area_name %in% c(
              "ALABAMA", "KENTUCKY", "MISSISSIPPI", "TENNESSEE"),
              "East South Central",
              ifelse(area_name %in% c(
                "ARKANSAS", "LOUISIANA", "OKLAHOMA", "TEXAS"),
                "West South Central",
                ifelse(area_name %in% c(
                  "ARIZONA", "COLORADO", "IDAHO", "MONTANA",
                  "NEVADA", "NEW MEXICO", "UTAH", "WYOMING"),
                  "Mountain",
                  ifelse(area_name %in% c(
                    "ALASKA", "CALIFORNIA", "HAWAII", "OREGON",
                    "WASHINGTON"), "Pacific", 
                  "ERROR"))))))))))
noncounty_data
```

# Data processing function creation

We now turn to a second data set EDU01b, which contains data structured similarly to EDU01a, with measurements from areas of the country taken across different years. In the steps below, we will recreate the steps above for this new data, but rather than simply copying code and modifying to apply to this one new data set, we will create functions that can apply the same set of steps to any similar data set.

### Import the data

To begin, we import the new data set we will be working with. Although this will ultimately incorporate this step into our final wrapper function, importing at this point allows us to build and test each component of our functions.

```{r}
census_1b_original <- read_csv("https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv")
head(census_1b_original)
```

### Function to Select Columns and Pivot to Long Form

Creating the first part of the function is fairly simple and includes the steps of selecting our columns, renaming and pivoting. Our arguments for the function are our tibble we imported and a default variable name which can be changed as appropriate for the data set. Testing the function produces a similar result as obtained with the first data set.

```{r}
process_data1 <- function(census_df, default_var_name = "enrollment") {
  census_df |>
    select(Area_name, STCOU, ends_with("D")) |>
    rename(area_name = Area_name) |>
    pivot_longer(cols = 3:12, 
                 names_to = "item_id", 
                 values_to = default_var_name)
}
#test function
result_step_1_2 <- process_data1(census_1b_original)
result_step_1_2
```

### Function to Add Year and Survey Code Columns

The next part of the function incorporates the addition of our two extra columns. In this case, we also take in our tibble, but don't need to specify the default variable since it was specified in the previous function. Testing the function returned the expected tibble.


```{r}
process_data2 <- function(census_df) {
  census_df |> 
    mutate(year = ifelse(substr(item_id, 7, 7)=="1", 
     (as.numeric(substr(item_id, 8, 9)) + 1900), 
     ifelse(substr(item_id, 7, 7)=="2", 
       (as.numeric(substr(item_id, 8, 9)) + 2000), 0)), 
      survey_code = substr(item_id, 1, 7))
}

#test the function
result_step_3 <- process_data2(result_step_1_2)
result_step_3
```


### Function to Add State Variable

Next, we create a function to perform step 5 from above, which will take the output from the previous step, extract the last two characters of the area_name variable and store this in a new "state" variable. Again, the only argument is the name of the census data tibble output from the previous step.

```{r}
add_state <- function(census_df) {
  census_df |>
    mutate(state = substr(area_name, nchar(area_name)-1,
                        nchar(area_name)))
}
#test function
result_step_5 <- add_state(result_step_3)
head(result_step_5)
#view(result_step_5)
```

### Function to Add Division Variable

Next, we create a function to assign each state to its corresponding division in the United States. Given that the data set has not yet been split between county and non-county data, this function should return "ERROR" for the majority of observations which correspond to county-level data.

```{r}
add_division <- function(census_df) {
  census_df |>
    mutate(division = ifelse(area_name %in% c(
      "CONNECTICUT", "MAINE", "MASSACHUSETTS", "NEW HAMPSHIRE", 
      "RHODE ISLAND", "VERMONT"), "New England",
      ifelse(area_name %in% c(
        "NEW JERSEY", "NEW YORK", "PENNSYLVANIA"),
        "Middle Atlantic",
        ifelse(area_name %in% c(
          "ILLINOIS", "INDIANA", "MICHIGAN", "OHIO", "WISCONSIN"),
          "East North Central",
          ifelse(area_name %in% c(
            "IOWA", "KANSAS", "MINNESOTA", "MISSOURI", "NEBRASKA",
            "NORTH DAKOTA", "SOUTH DAKOTA"), "West North Central",
            ifelse(area_name %in% c(
              "DELAWARE", "FLORIDA", "GEORGIA", "MARYLAND", 
              "NORTH CAROLINA", "SOUTH CAROLINA", "VIRGINIA", 
              "DISTRICT OF COLUMBIA", "District of Columbia", 
              "WEST VIRGINIA"), "South Atlantic", 
              ifelse(area_name %in% c(
                "ALABAMA", "KENTUCKY", "MISSISSIPPI",
                "TENNESSEE"), "East South Central", 
                ifelse(area_name %in% c(
                  "ARKANSAS", "LOUISIANA", "OKLAHOMA", "TEXAS"),
                  "West South Central",
                  ifelse(area_name %in% c(
                    "ARIZONA", "COLORADO", "IDAHO", "MONTANA",
                    "NEVADA", "NEW MEXICO", "UTAH", "WYOMING"),
                    "Mountain", 
                    ifelse(area_name %in% c(
                      "ALASKA", "CALIFORNIA", "HAWAII", "OREGON", 
                      "WASHINGTON"), "Pacific", "ERROR"))))))))))
}
#test function
result_step_6 <- add_division(result_step_5)
head(result_step_6)
```

### Function for step 4

Here, we create a function that will split the data into two datasets (one for county-level data, and one for non-county data), and then calls the above two functions to add the new variable to each new tibble.

```{r}
split_data <- function(census_df) {
  county_data <- census_df |>
    filter(grepl(pattern = ", \\w\\w", area_name))
  class(county_data) <- c("county", class(county_data)) 
  county_data <- add_state(county_data)
  
  noncounty_data <- census_df |>
    filter(!grepl(pattern = ", \\w\\w", area_name)) 
  class(noncounty_data) <- c("state", class(noncounty_data)) 
  add_division(noncounty_data)
  return(list(county_data, noncounty_data))
}
#test function
census_df_list <- split_data(result_step_3)
census_df_list
#check class
str(census_df_list)
```

## Final data processing wrapper function

```{r}
data_processing_wrapper <- function(url, default_var_name = "measurement") {
  result <- read_csv(url) |>
    process_data1() |>
    process_data2()
    return(result)
}
data_processing_wrapper("https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv")
```
